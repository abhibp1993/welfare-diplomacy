"""
Charts for Super Exploitation experiments.
"""

import os

import matplotlib.pyplot as plt
import pandas as pd
import seaborn as sns

from chart_utils import (
    ALL_POWER_ABBREVIATIONS,
    COLOR_ALT_1,
    COLOR_ALT_2,
    MODEL_NAME_TO_COLOR,
    MODEL_NAME_TO_DISPLAY_NAME,
    MODEL_ORDER_NO_EXPLOITER,
    initialize_plot_bar,
    initialize_plot_default,
    geometric_mean,
    get_results_full_path,
    save_plot,
)

INPUT_FILES_MODELS = [
    "../results/super_exploitation/SE-1 Claude Both.csv",
    "../results/super_exploitation/SE-1 GPT-3.5.csv",
    "../results/super_exploitation/SE-1 GPT-4-Base.csv",
    "../results/super_exploitation/SE-1 GPT-4.csv",
    "../results/super_exploitation/SE-2 Claude Both.csv",
    "../results/super_exploitation/SE-2 GPT-3.5.csv",
    "../results/super_exploitation/SE-2 GPT-4-Base.csv",
    "../results/super_exploitation/SE-2 GPT-4.csv",
    "../results/super_exploitation/SE Llama2-70b-chat.csv",
]
INPUT_FILE_OPTIMAL_PROSOCIAL = "../results/same_policy/Optimal Prosocial.csv"
INPUT_FILE_RANDOM = "../results/same_policy/SP Random.csv"

OUTPUT_DIR = "super_exploitation"


def main() -> None:
    """Main function."""

    # Load the data from each file into one big dataframe
    df_models = pd.concat(
        [pd.read_csv(get_results_full_path(f)) for f in INPUT_FILES_MODELS]
    )

    # Load other data
    df_optimal_prosocial = pd.read_csv(
        get_results_full_path(INPUT_FILE_OPTIMAL_PROSOCIAL)
    )
    df_random = pd.read_csv(get_results_full_path(INPUT_FILE_RANDOM))
    df_random["agent_model"] = "Random"
    df_model_power_wp = pd.read_csv(
        get_results_full_path(os.path.join("same_policy", "SP Model Power WP.csv"))
    )

    # Rename models based on MODEL_NAME_TO_DISPLAY_NAME
    df_models["agent_model"] = df_models["agent_model"].replace(
        MODEL_NAME_TO_DISPLAY_NAME
    )

    # Print how many runs there are for each agent_model
    print(f"Runs per agent_model:")
    print(df_models.groupby(["agent_model"]).size())

    # Print average _progress/percent_done for each agent_model
    print(f"Average _progress/percent_done per agent_model:")
    print(df_models.groupby(["agent_model"])["_progress/percent_done"].mean())

    # Print average _progress/year_fractional for each agent_model
    print(f"Average _progress/year_fractional per agent_model:")
    print(df_models.groupby(["agent_model"])["_progress/year_fractional"].mean())

    # Calculate root Nash welfare for normal language model coalition and exploiter coalition in new columns by iterating over rows
    nash_welfare_baseline = []
    nash_welfare_exploiter = []
    for _, exploitation_row in df_models.iterrows():
        # Determine which powers are in which coalition
        exploiter_power_abbreviation = exploitation_row["super_exploiter_powers"].split(
            ","
        )
        exploiter_power_abbreviation = [
            name[:3].upper() for name in exploiter_power_abbreviation
        ]
        assert len(exploiter_power_abbreviation) > 0
        assert len(exploiter_power_abbreviation) < len(ALL_POWER_ABBREVIATIONS)
        assert all(
            [power in ALL_POWER_ABBREVIATIONS for power in exploiter_power_abbreviation]
        )

        # Get welfare scores for each coalition
        years_passed = int(exploitation_row["_progress/year_fractional"])
        welfare_list_baseline = [
            exploitation_row[f"score/welfare/{power}"] / years_passed
            for power in ALL_POWER_ABBREVIATIONS
            if power not in exploiter_power_abbreviation
        ]
        welfare_list_exploiter = [
            exploitation_row[f"score/welfare/{power}"] / years_passed
            for power in exploiter_power_abbreviation
        ]

        # Calculate root Nash welfare for normal language model coalition
        nash_welfare_baseline.append(geometric_mean(welfare_list_baseline))
        # Calculate root Nash welfare for exploiter coalition
        nash_welfare_exploiter.append(geometric_mean(welfare_list_exploiter))

    # Add the new columns to the dataframe
    df_models[
        "benchmark/nash_social_welfare_baseline_recalculated"
    ] = nash_welfare_baseline
    df_models[
        "benchmark/nash_social_welfare_exploiter_recalculated"
    ] = nash_welfare_exploiter

    # Create separate graphs for different numbers of exploiters
    for num_exploiters in [1, 2, "All"]:
        # Filter the dataframe to only include runs with the specified number of exploiters
        if num_exploiters == "All":
            df_models_filtered = df_models.copy()
        else:
            df_models_filtered = df_models[
                df_models["num_super_exploiter_powers"] == num_exploiters
            ].copy()

        # Plot a bunch of different bar graphs for different metrics
        for (
            metric_name,
            y_label,
            improvement_sign,
            optimal_prosocial_metric,
            random_metric,
            y_bounds,
            legend_loc,
        ) in [
            (
                "benchmark/nash_social_welfare_global",
                "Root Nash Welfare (Global)",
                1,
                "benchmark/nash_social_welfare_global",
                "benchmark/nash_social_welfare_global",
                (None, None),
                (0.0, 0.75),
            ),
            (
                "benchmark/nash_social_welfare_baseline_recalculated",
                "Root Nash Welfare (Baseline)",
                1,
                "benchmark/nash_social_welfare_global",
                "benchmark/nash_social_welfare_global",
                (None, None),
                (0.0, 0.75),
            ),
            (
                "benchmark/nash_social_welfare_exploiter_recalculated",
                "Root Nash Welfare (Exploiter)",
                1,
                "benchmark/nash_social_welfare_global",
                "benchmark/nash_social_welfare_global",
                (None, None),
                (0.0, 0.75),
            ),
            (
                "benchmark/competence_score",
                "Basic Proficiency",
                1,
                "",
                "",
                (0.65, 1.005),
                "best",
            ),
            (
                "combat/game_conflicts_avg",
                "Average Conflicts per Turn",
                -1,
                "",
                "combat/game_conflicts_avg",
                (None, None),
                "best",
            ),
        ]:
            # Initialize
            initialize_plot_bar()

            # Plot the welfare scores for each power
            cols_of_interest = [
                "agent_model",
                metric_name,
            ]

            plot_df = df_models_filtered[cols_of_interest].copy()

            # update the column names
            x_label = "Agent Model"
            plot_df.columns = [x_label, y_label]

            # Create the plot
            model_order = MODEL_ORDER_NO_EXPLOITER
            if "Optimal Prosocial" in model_order:
                model_order.remove("Optimal Prosocial")
            if "Random Policy" in model_order:
                model_order.remove("Random Policy")
            plot = sns.barplot(
                data=plot_df,
                x=x_label,
                y=y_label,
                errorbar="ci",
                order=model_order,
                capsize=0.2,
                hue=x_label,
                palette=MODEL_NAME_TO_COLOR,
                # errwidth=2,
            )

            if optimal_prosocial_metric:
                # Add horizontal line for optimal prosocial with label
                optimal_prosocial = df_optimal_prosocial[optimal_prosocial_metric].iloc[
                    0
                ]
                plot.axhline(
                    optimal_prosocial,
                    color=COLOR_ALT_1,
                    linestyle="--",
                    linewidth=2,
                    label="Optimal Prosocial",
                )
                plt.legend(loc=legend_loc)

            if random_metric:
                # Calculate the average of the metric for random
                random_avg = df_random[random_metric].mean()
                # Add horizontal line for random with label
                plot.axhline(
                    random_avg,
                    color=COLOR_ALT_2,
                    linestyle="--",
                    linewidth=2,
                    label="Random Policy",
                )
                plt.legend(loc=legend_loc)

            # Set labels and title
            plt.xlabel(x_label)
            y_axis_label = y_label
            if improvement_sign == 1:
                y_axis_label += " →"
            elif improvement_sign == -1:
                y_axis_label += " ←"
            plt.ylabel(y_axis_label)
            title = f"{y_label} by Model ({num_exploiters} Exploiters)"
            if num_exploiters == 1:
                title = title.replace("Exploiters", "Exploiter")
            plt.title(title)

            # Set y bounds
            if y_bounds[0] is not None:
                plt.ylim(bottom=y_bounds[0])
            if y_bounds[1] is not None:
                plt.ylim(top=y_bounds[1])

            # Save the plot
            output_file = get_results_full_path(
                os.path.join(OUTPUT_DIR, f"SE-{num_exploiters} {y_label}.png")
            )
            save_plot(output_file)
            print(f"Saved plot '{title}' to {output_file}")

            # Clear the plot
            plt.clf()

        # Special plot: Exploitation score
        # defined as
        # max_{coalition in tested coalition combinations} [
        #   min_{exploiting power in coalition} (
        #       exploiter_welfare_in_this_game - avg_welfare_of_same_power_in_self_play_experiments ) ]
        # where the average self-play welfare is preprocessed in same_policy.py
        models_and_exploitabilities: list[tuple[str, float]] = []
        for _ in range(5):
            for agent_model in df_models_filtered["agent_model"].unique():
                # Filter to the games with this agent model
                df_agent_model = df_models_filtered[
                    df_models_filtered["agent_model"] == agent_model
                ].copy()

                all_game_exploitabilities = []
                # Iterate over the games
                for _, exploitation_row in df_agent_model.iterrows():
                    # Determine which powers are in which coalition
                    exploiter_power_abbreviation = exploitation_row[
                        "super_exploiter_powers"
                    ].split(",")
                    exploiter_power_abbreviation = [
                        name[:3].upper() for name in exploiter_power_abbreviation
                    ]
                    assert len(exploiter_power_abbreviation) > 0
                    assert len(exploiter_power_abbreviation) < len(
                        ALL_POWER_ABBREVIATIONS
                    )
                    assert all(
                        [
                            power in ALL_POWER_ABBREVIATIONS
                            for power in exploiter_power_abbreviation
                        ]
                    )

                    # Calculate how much each exploiter improves on its powers self-play average
                    years_passed = int(exploitation_row["_progress/year_fractional"])
                    df_self_play_model_results = df_model_power_wp[
                        df_model_power_wp["agent_model"].apply(
                            MODEL_NAME_TO_DISPLAY_NAME.get
                        )
                        == agent_model
                    ]
                    assert years_passed > 0
                    assert all(
                        years_passed == self_play_years_passed
                        for self_play_years_passed in df_self_play_model_results[
                            "_progress/year_integer"
                        ]
                    )
                    # Sample 5 of the self-play runs with replacement
                    df_self_play_model_results = df_self_play_model_results.sample(
                        n=5, replace=True
                    )
                    yearly_exploit_gains = [
                        exploitation_row[f"score/welfare/{power}"] / years_passed
                        - df_self_play_model_results[f"yearly_welfare/{power}"].mean()
                        for power in exploiter_power_abbreviation
                    ]
                    game_exploitability = min(yearly_exploit_gains)
                    all_game_exploitabilities.append(game_exploitability)
                model_exploitability = max(all_game_exploitabilities)
                models_and_exploitabilities.append((agent_model, model_exploitability))
        df_exploitability = pd.DataFrame(
            models_and_exploitabilities, columns=["agent_model", "exploitability"]
        )

        # Plot exploitation score
        initialize_plot_bar()
        model_order = MODEL_ORDER_NO_EXPLOITER
        if "Optimal Prosocial" in model_order:
            model_order.remove("Optimal Prosocial")
        if "Random Policy" in model_order:
            model_order.remove("Random Policy")
        sns.barplot(
            data=df_exploitability,
            x="agent_model",
            y="exploitability",
            order=model_order,
            palette=MODEL_NAME_TO_COLOR,
            capsize=0.2,
        )
        plt.xlabel("Agent Model")
        plt.ylabel("Exploitability ←")
        title = f"Model Exploitability ({num_exploiters} Exploiters)"
        if num_exploiters == 1:
            title = title.replace("Exploiters", "Exploiter")
        plt.title(title)
        if num_exploiters != "All":
            # Manually set y-limit so the graphs are comparable
            plt.ylim(top=8.5)
        output_file = get_results_full_path(
            os.path.join(OUTPUT_DIR, f"SE-{num_exploiters} Exploitability.png")
        )
        save_plot(output_file)
        print(f"Saved plot '{title}' to {output_file}")
        plt.clf()

        # Special plot: Scatterplot of global root Nash welfare vs conflicts for all runs
        df_plot = df_models_filtered.copy()
        df_plot["agent_model"] = df_plot["agent_model"].str.replace("\n", " ")
        grouping = "Agent Model"
        df_plot = df_plot.rename(columns={"agent_model": grouping})
        initialize_plot_default()
        plt.rcParams["lines.marker"] = ""
        sns.regplot(
            data=df_plot,
            x="combat/game_conflicts_avg",
            y="benchmark/nash_social_welfare_global",
            scatter=False,
            color=COLOR_ALT_1,
        )
        initialize_plot_default()
        plt.rcParams["lines.markersize"] = 14
        sns.scatterplot(
            data=df_plot,
            x="combat/game_conflicts_avg",
            y="benchmark/nash_social_welfare_global",
            hue=grouping,
            style=grouping,
            palette=MODEL_NAME_TO_COLOR,
        )
        plt.xlabel("Average Conflicts per Turn ↓")
        plt.ylabel("Root Nash Welfare (Global) →")

        title = f"Root Nash Welfare (Global) vs Conflicts({num_exploiters} Exploiters)"
        if num_exploiters == 1:
            title = title.replace("Exploiters", "Exploiter")
        plt.title(title)
        # Legend in 2 columns
        plt.legend(
            borderaxespad=0.0,
            ncol=2,
            handletextpad=0.1,
            columnspacing=0.5,
        )
        output_file = get_results_full_path(
            os.path.join(
                OUTPUT_DIR,
                f"SE-{num_exploiters} Root Nash Welfare (Global) vs Conflicts.png",
            )
        )
        save_plot(output_file)
        print(f"Saved plot '{title}' to {output_file}")
        plt.clf()


if __name__ == "__main__":
    main()
