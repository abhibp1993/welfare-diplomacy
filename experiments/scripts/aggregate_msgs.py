"""
Description: Given a message table generated by simulate_game.py containing the columns
    `phase, round, sender, recipient, message`, this script generates a CSV with the
    following columns:
        phase,
        power1,
        power2,
        dialogue,
        locations,      # locations discussed in the dialogue between powers 1, 2 during the phase.
        units discussed,            # all units discussed in the dialogue between powers 1, 2 during the phase.
        agreements explored,        # agreements discussed in the dialogue between powers 1, 2 during the phase.
        contracts signed,           # contracts signed between powers 1, 2 during the phase.

Date: 25 Feb 2025

Author: Abhishek N. Kulkarni
"""
import pandas as pd
from itertools import combinations
from pathlib import Path
from loguru import logger


def load_csv(path):
    """
    Load the CSV file containing the message table.
    If the CSV does NOT have the following columns, then exception is raised.
        `phase, round, sender, recipient, message`.

    Args:
        path (str): Path to the CSV file.

    Returns:
        pd.DataFrame: DataFrame containing the message table.
    """
    df_ = pd.read_csv(path)
    assert set(df_.columns.tolist()) == {"phase", "round", "sender", "recipient", "message"}, \
        f"Columns in the CSV file are not as expected. Expected: ['phase', 'round', 'sender', 'recipient', 'message']"

    return df_


def aggregate_phase_dialogues(df):
    """
    Given a DataFrame containing the message table, this function aggregates the dialogues
    exchanged between pairs of participants in each phase.

    Args:
        df (pd.DataFrame): DataFrame containing the message table.

    Returns:
        pd.DataFrame: DataFrame containing the aggregated dialogues.
    """
    # Group by phase
    grouped = df.groupby("phase")

    # Process each phase
    data = []
    for phase, group in grouped:
        # Get all unique participants
        participants = set(group["sender"]).union(set(group["recipient"]))

        # Generate all pairs of participants
        for power1, power2 in combinations(participants, 2):
            # Filter messages exchanged between power1 and power2
            messages = group[((group["sender"] == power1) & (group["recipient"] == power2)) |
                             ((group["sender"] == power2) & (group["recipient"] == power1))]

            if not messages.empty:
                # Concatenate messages into a dialogue string
                dialogue = " \n\n ".join(f"{row['sender']} to {row['recipient']}: {row['message']}" for _, row in messages.iterrows())

                # Append to result list
                data.append([phase, power1, power2, dialogue])

    # Create output DataFrame
    return pd.DataFrame(data, columns=["phase", "power1", "power2", "dialogue"])


if __name__ == '__main__':
    # Load the CSV file
    csv_file_path = Path(__file__).resolve().parents[1] / "games" / "5-light-haze"
    input_df = load_csv(csv_file_path / "5-light-haze-message-table.csv")

    # Aggregate dialogues
    output_df = aggregate_phase_dialogues(input_df)

    # Save to CSV
    output_df.to_csv(csv_file_path / "5-light-haze-aggregate-msg-table.csv", index=False)
    logger.success(f"Saved aggregated message table to {csv_file_path / '5-light-haze-aggregate-msg-table.csv'}")
